# On C# Design Patterns

In 1994, four authors (Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides) published a book called **Design Patterns: Elements of Reusable Object-Oriented Software**, which explained the concept of design patterns in software development. These four authors are collectively known as Gang of Four.

This repository is a collection of demonstrations for each of the 23 design patterns used in C#. Here, you will find 23 Visual Studio projects that demonstrate how C# design patterns are used in real world applications.

There are three groupos of design patterns; **Creational**, **Structural**, and **Behavioral**. Each group solves a different type of common problem found in software architecture. 

To figure out which of the 23 patterns to use for a given problem, you must first understand what each pattern is used for.

### Creational Patterns
| |
--- | ---
**Abstract Factory** | Creates an instance of several families of classes
**Builder** | Separates object construction from its representation
**Factory Method** | Creats an instance of several derived classes
**Prototype** | A fully initialized instance used to be cloned
**Singleton** | A class of which only a single instance can exist

### Structural Patterns
| | 
--- | ---
**Adapter** | Match interfaces of different classes
**Bridge** | Separates an object's interface from its implementation
**Composite** | A tree structure of simple and composite objects
**Decorator** | Add responsibilities to objects dynamically
**Facade** | A single class that represents an entire subsystem
**Flyweight** | A fine-grained instance used for efficient sharing
**Proxy** | An object representing another object

### Behavioral Patterns
| | 
--- | ---
**Chain of Responsibility** | A way of passing a request between a chain of objects
**Command** | Encapsulates a command request as an object
**Interpreter** | A way to include language elements in a program
**Iterator** | Sequentially access the elements of a collection
**Mediator** | Defines simplified communication between classes
**Memento** | Capture and resotre an object's innternal state
**Observer** | A way of notifying change to a number of classes
**State** | Alter an object's behavior when the state changes
**Strategy** | Encapsulates an algorithm inside a class
**Template Method** | Defer tjhe exact steps of an algorithm to a subclass
**Visitor** | Defines a new operation to a class without change